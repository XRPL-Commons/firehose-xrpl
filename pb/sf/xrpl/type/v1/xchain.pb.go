// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: sf/xrpl/type/v1/xchain.proto

package pbxrpl

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// XChainBridge - Cross-chain bridge specification
type XChainBridge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Door account on locking chain
	LockingChainDoor string `protobuf:"bytes,1,opt,name=locking_chain_door,json=lockingChainDoor,proto3" json:"locking_chain_door,omitempty"`
	// Issue on locking chain
	LockingChainIssue *Asset `protobuf:"bytes,2,opt,name=locking_chain_issue,json=lockingChainIssue,proto3" json:"locking_chain_issue,omitempty"`
	// Door account on issuing chain
	IssuingChainDoor string `protobuf:"bytes,3,opt,name=issuing_chain_door,json=issuingChainDoor,proto3" json:"issuing_chain_door,omitempty"`
	// Issue on issuing chain
	IssuingChainIssue *Asset `protobuf:"bytes,4,opt,name=issuing_chain_issue,json=issuingChainIssue,proto3" json:"issuing_chain_issue,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *XChainBridge) Reset() {
	*x = XChainBridge{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainBridge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainBridge) ProtoMessage() {}

func (x *XChainBridge) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainBridge.ProtoReflect.Descriptor instead.
func (*XChainBridge) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{0}
}

func (x *XChainBridge) GetLockingChainDoor() string {
	if x != nil {
		return x.LockingChainDoor
	}
	return ""
}

func (x *XChainBridge) GetLockingChainIssue() *Asset {
	if x != nil {
		return x.LockingChainIssue
	}
	return nil
}

func (x *XChainBridge) GetIssuingChainDoor() string {
	if x != nil {
		return x.IssuingChainDoor
	}
	return ""
}

func (x *XChainBridge) GetIssuingChainIssue() *Asset {
	if x != nil {
		return x.IssuingChainIssue
	}
	return nil
}

// XChainCreateBridge - Creates a new bridge
// Reference: https://xrpl.org/xchaincreatebrige.html
type XChainCreateBridge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Reward for attestation signers
	SignatureReward *Amount `protobuf:"bytes,2,opt,name=signature_reward,json=signatureReward,proto3" json:"signature_reward,omitempty"`
	// (Optional) Minimum amount for account creation
	MinAccountCreateAmount *Amount `protobuf:"bytes,3,opt,name=min_account_create_amount,json=minAccountCreateAmount,proto3" json:"min_account_create_amount,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *XChainCreateBridge) Reset() {
	*x = XChainCreateBridge{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainCreateBridge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainCreateBridge) ProtoMessage() {}

func (x *XChainCreateBridge) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainCreateBridge.ProtoReflect.Descriptor instead.
func (*XChainCreateBridge) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{1}
}

func (x *XChainCreateBridge) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainCreateBridge) GetSignatureReward() *Amount {
	if x != nil {
		return x.SignatureReward
	}
	return nil
}

func (x *XChainCreateBridge) GetMinAccountCreateAmount() *Amount {
	if x != nil {
		return x.MinAccountCreateAmount
	}
	return nil
}

// XChainModifyBridge - Modifies bridge parameters
// Reference: https://xrpl.org/xchainmodifybridge.html
type XChainModifyBridge struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// (Optional) New signature reward
	SignatureReward *Amount `protobuf:"bytes,2,opt,name=signature_reward,json=signatureReward,proto3" json:"signature_reward,omitempty"`
	// (Optional) New minimum for account creation
	MinAccountCreateAmount *Amount `protobuf:"bytes,3,opt,name=min_account_create_amount,json=minAccountCreateAmount,proto3" json:"min_account_create_amount,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *XChainModifyBridge) Reset() {
	*x = XChainModifyBridge{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainModifyBridge) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainModifyBridge) ProtoMessage() {}

func (x *XChainModifyBridge) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainModifyBridge.ProtoReflect.Descriptor instead.
func (*XChainModifyBridge) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{2}
}

func (x *XChainModifyBridge) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainModifyBridge) GetSignatureReward() *Amount {
	if x != nil {
		return x.SignatureReward
	}
	return nil
}

func (x *XChainModifyBridge) GetMinAccountCreateAmount() *Amount {
	if x != nil {
		return x.MinAccountCreateAmount
	}
	return nil
}

// XChainCreateClaimID - Creates a claim ID for cross-chain transfer
// Reference: https://xrpl.org/xchaincreateclaimid.html
type XChainCreateClaimID struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Reward to pay attesters
	SignatureReward *Amount `protobuf:"bytes,2,opt,name=signature_reward,json=signatureReward,proto3" json:"signature_reward,omitempty"`
	// Account on source chain initiating transfer
	OtherChainSource string `protobuf:"bytes,3,opt,name=other_chain_source,json=otherChainSource,proto3" json:"other_chain_source,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *XChainCreateClaimID) Reset() {
	*x = XChainCreateClaimID{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainCreateClaimID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainCreateClaimID) ProtoMessage() {}

func (x *XChainCreateClaimID) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainCreateClaimID.ProtoReflect.Descriptor instead.
func (*XChainCreateClaimID) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{3}
}

func (x *XChainCreateClaimID) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainCreateClaimID) GetSignatureReward() *Amount {
	if x != nil {
		return x.SignatureReward
	}
	return nil
}

func (x *XChainCreateClaimID) GetOtherChainSource() string {
	if x != nil {
		return x.OtherChainSource
	}
	return ""
}

// XChainCommit - Initiates a cross-chain transfer
// Reference: https://xrpl.org/xchaincommit.html
type XChainCommit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Claim ID from XChainCreateClaimID
	XchainClaimId uint64 `protobuf:"varint,2,opt,name=xchain_claim_id,json=xchainClaimId,proto3" json:"xchain_claim_id,omitempty"`
	// Amount to transfer
	Amount *Amount `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// (Optional) Destination on other chain
	OtherChainDestination string `protobuf:"bytes,4,opt,name=other_chain_destination,json=otherChainDestination,proto3" json:"other_chain_destination,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *XChainCommit) Reset() {
	*x = XChainCommit{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainCommit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainCommit) ProtoMessage() {}

func (x *XChainCommit) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainCommit.ProtoReflect.Descriptor instead.
func (*XChainCommit) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{4}
}

func (x *XChainCommit) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainCommit) GetXchainClaimId() uint64 {
	if x != nil {
		return x.XchainClaimId
	}
	return 0
}

func (x *XChainCommit) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *XChainCommit) GetOtherChainDestination() string {
	if x != nil {
		return x.OtherChainDestination
	}
	return ""
}

// XChainClaim - Claims transferred funds on destination chain
// Reference: https://xrpl.org/xchainclaim.html
type XChainClaim struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Claim ID
	XchainClaimId uint64 `protobuf:"varint,2,opt,name=xchain_claim_id,json=xchainClaimId,proto3" json:"xchain_claim_id,omitempty"`
	// Destination account
	Destination string `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
	// (Optional) Destination tag
	DestinationTag uint32 `protobuf:"varint,4,opt,name=destination_tag,json=destinationTag,proto3" json:"destination_tag,omitempty"`
	// Amount being claimed
	Amount        *Amount `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *XChainClaim) Reset() {
	*x = XChainClaim{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainClaim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainClaim) ProtoMessage() {}

func (x *XChainClaim) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainClaim.ProtoReflect.Descriptor instead.
func (*XChainClaim) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{5}
}

func (x *XChainClaim) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainClaim) GetXchainClaimId() uint64 {
	if x != nil {
		return x.XchainClaimId
	}
	return 0
}

func (x *XChainClaim) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *XChainClaim) GetDestinationTag() uint32 {
	if x != nil {
		return x.DestinationTag
	}
	return 0
}

func (x *XChainClaim) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

// XChainAccountCreateCommit - Creates account on destination chain
// Reference: https://xrpl.org/xchainaccountcreatecommit.html
type XChainAccountCreateCommit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Destination account to create
	Destination string `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Amount to fund new account
	Amount *Amount `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// Reward for attesters
	SignatureReward *Amount `protobuf:"bytes,4,opt,name=signature_reward,json=signatureReward,proto3" json:"signature_reward,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *XChainAccountCreateCommit) Reset() {
	*x = XChainAccountCreateCommit{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainAccountCreateCommit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainAccountCreateCommit) ProtoMessage() {}

func (x *XChainAccountCreateCommit) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainAccountCreateCommit.ProtoReflect.Descriptor instead.
func (*XChainAccountCreateCommit) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{6}
}

func (x *XChainAccountCreateCommit) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainAccountCreateCommit) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *XChainAccountCreateCommit) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *XChainAccountCreateCommit) GetSignatureReward() *Amount {
	if x != nil {
		return x.SignatureReward
	}
	return nil
}

// XChainAddClaimAttestation - Adds attestation for a claim
// Reference: https://xrpl.org/xchainaddclaimattestation.html
type XChainAddClaimAttestation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Account attesting to the claim
	AttestationSignerAccount string `protobuf:"bytes,2,opt,name=attestation_signer_account,json=attestationSignerAccount,proto3" json:"attestation_signer_account,omitempty"`
	// Public key of signer (hex)
	PublicKey string `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Signature (hex)
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// Source account on other chain
	OtherChainSource string `protobuf:"bytes,5,opt,name=other_chain_source,json=otherChainSource,proto3" json:"other_chain_source,omitempty"`
	// Amount being attested
	Amount *Amount `protobuf:"bytes,6,opt,name=amount,proto3" json:"amount,omitempty"`
	// Account receiving attestation reward
	AttestationRewardAccount string `protobuf:"bytes,7,opt,name=attestation_reward_account,json=attestationRewardAccount,proto3" json:"attestation_reward_account,omitempty"`
	// Whether transaction was on locking chain
	WasLockingChainSend bool `protobuf:"varint,8,opt,name=was_locking_chain_send,json=wasLockingChainSend,proto3" json:"was_locking_chain_send,omitempty"`
	// Claim ID being attested
	XchainClaimId uint64 `protobuf:"varint,9,opt,name=xchain_claim_id,json=xchainClaimId,proto3" json:"xchain_claim_id,omitempty"`
	// (Optional) Destination account
	Destination   string `protobuf:"bytes,10,opt,name=destination,proto3" json:"destination,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *XChainAddClaimAttestation) Reset() {
	*x = XChainAddClaimAttestation{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainAddClaimAttestation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainAddClaimAttestation) ProtoMessage() {}

func (x *XChainAddClaimAttestation) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainAddClaimAttestation.ProtoReflect.Descriptor instead.
func (*XChainAddClaimAttestation) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{7}
}

func (x *XChainAddClaimAttestation) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainAddClaimAttestation) GetAttestationSignerAccount() string {
	if x != nil {
		return x.AttestationSignerAccount
	}
	return ""
}

func (x *XChainAddClaimAttestation) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *XChainAddClaimAttestation) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *XChainAddClaimAttestation) GetOtherChainSource() string {
	if x != nil {
		return x.OtherChainSource
	}
	return ""
}

func (x *XChainAddClaimAttestation) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *XChainAddClaimAttestation) GetAttestationRewardAccount() string {
	if x != nil {
		return x.AttestationRewardAccount
	}
	return ""
}

func (x *XChainAddClaimAttestation) GetWasLockingChainSend() bool {
	if x != nil {
		return x.WasLockingChainSend
	}
	return false
}

func (x *XChainAddClaimAttestation) GetXchainClaimId() uint64 {
	if x != nil {
		return x.XchainClaimId
	}
	return 0
}

func (x *XChainAddClaimAttestation) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

// XChainAddAccountCreateAttestation - Adds attestation for account creation
// Reference: https://xrpl.org/xchainaddaccountcreateattestation.html
type XChainAddAccountCreateAttestation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bridge specification
	XchainBridge *XChainBridge `protobuf:"bytes,1,opt,name=xchain_bridge,json=xchainBridge,proto3" json:"xchain_bridge,omitempty"`
	// Account attesting
	AttestationSignerAccount string `protobuf:"bytes,2,opt,name=attestation_signer_account,json=attestationSignerAccount,proto3" json:"attestation_signer_account,omitempty"`
	// Public key of signer (hex)
	PublicKey string `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Signature (hex)
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// Source account on other chain
	OtherChainSource string `protobuf:"bytes,5,opt,name=other_chain_source,json=otherChainSource,proto3" json:"other_chain_source,omitempty"`
	// Amount being attested
	Amount *Amount `protobuf:"bytes,6,opt,name=amount,proto3" json:"amount,omitempty"`
	// Account receiving attestation reward
	AttestationRewardAccount string `protobuf:"bytes,7,opt,name=attestation_reward_account,json=attestationRewardAccount,proto3" json:"attestation_reward_account,omitempty"`
	// Whether transaction was on locking chain
	WasLockingChainSend bool `protobuf:"varint,8,opt,name=was_locking_chain_send,json=wasLockingChainSend,proto3" json:"was_locking_chain_send,omitempty"`
	// Account creation count
	XchainAccountCreateCount uint64 `protobuf:"varint,9,opt,name=xchain_account_create_count,json=xchainAccountCreateCount,proto3" json:"xchain_account_create_count,omitempty"`
	// Destination account to create
	Destination string `protobuf:"bytes,10,opt,name=destination,proto3" json:"destination,omitempty"`
	// Reward for attesters
	SignatureReward *Amount `protobuf:"bytes,11,opt,name=signature_reward,json=signatureReward,proto3" json:"signature_reward,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *XChainAddAccountCreateAttestation) Reset() {
	*x = XChainAddAccountCreateAttestation{}
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XChainAddAccountCreateAttestation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XChainAddAccountCreateAttestation) ProtoMessage() {}

func (x *XChainAddAccountCreateAttestation) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_xchain_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XChainAddAccountCreateAttestation.ProtoReflect.Descriptor instead.
func (*XChainAddAccountCreateAttestation) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP(), []int{8}
}

func (x *XChainAddAccountCreateAttestation) GetXchainBridge() *XChainBridge {
	if x != nil {
		return x.XchainBridge
	}
	return nil
}

func (x *XChainAddAccountCreateAttestation) GetAttestationSignerAccount() string {
	if x != nil {
		return x.AttestationSignerAccount
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetPublicKey() string {
	if x != nil {
		return x.PublicKey
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetOtherChainSource() string {
	if x != nil {
		return x.OtherChainSource
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *XChainAddAccountCreateAttestation) GetAttestationRewardAccount() string {
	if x != nil {
		return x.AttestationRewardAccount
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetWasLockingChainSend() bool {
	if x != nil {
		return x.WasLockingChainSend
	}
	return false
}

func (x *XChainAddAccountCreateAttestation) GetXchainAccountCreateCount() uint64 {
	if x != nil {
		return x.XchainAccountCreateCount
	}
	return 0
}

func (x *XChainAddAccountCreateAttestation) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *XChainAddAccountCreateAttestation) GetSignatureReward() *Amount {
	if x != nil {
		return x.SignatureReward
	}
	return nil
}

var File_sf_xrpl_type_v1_xchain_proto protoreflect.FileDescriptor

const file_sf_xrpl_type_v1_xchain_proto_rawDesc = "" +
	"\n" +
	"\x1csf/xrpl/type/v1/xchain.proto\x12\x0fsf.xrpl.type.v1\x1a\x1csf/xrpl/type/v1/amount.proto\"\xfa\x01\n" +
	"\fXChainBridge\x12,\n" +
	"\x12locking_chain_door\x18\x01 \x01(\tR\x10lockingChainDoor\x12F\n" +
	"\x13locking_chain_issue\x18\x02 \x01(\v2\x16.sf.xrpl.type.v1.AssetR\x11lockingChainIssue\x12,\n" +
	"\x12issuing_chain_door\x18\x03 \x01(\tR\x10issuingChainDoor\x12F\n" +
	"\x13issuing_chain_issue\x18\x04 \x01(\v2\x16.sf.xrpl.type.v1.AssetR\x11issuingChainIssue\"\xf0\x01\n" +
	"\x12XChainCreateBridge\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12B\n" +
	"\x10signature_reward\x18\x02 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x0fsignatureReward\x12R\n" +
	"\x19min_account_create_amount\x18\x03 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x16minAccountCreateAmount\"\xf0\x01\n" +
	"\x12XChainModifyBridge\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12B\n" +
	"\x10signature_reward\x18\x02 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x0fsignatureReward\x12R\n" +
	"\x19min_account_create_amount\x18\x03 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x16minAccountCreateAmount\"\xcb\x01\n" +
	"\x13XChainCreateClaimID\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12B\n" +
	"\x10signature_reward\x18\x02 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x0fsignatureReward\x12,\n" +
	"\x12other_chain_source\x18\x03 \x01(\tR\x10otherChainSource\"\xe3\x01\n" +
	"\fXChainCommit\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12&\n" +
	"\x0fxchain_claim_id\x18\x02 \x01(\x04R\rxchainClaimId\x12/\n" +
	"\x06amount\x18\x03 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\x126\n" +
	"\x17other_chain_destination\x18\x04 \x01(\tR\x15otherChainDestination\"\xf5\x01\n" +
	"\vXChainClaim\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12&\n" +
	"\x0fxchain_claim_id\x18\x02 \x01(\x04R\rxchainClaimId\x12 \n" +
	"\vdestination\x18\x03 \x01(\tR\vdestination\x12'\n" +
	"\x0fdestination_tag\x18\x04 \x01(\rR\x0edestinationTag\x12/\n" +
	"\x06amount\x18\x05 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\"\xf6\x01\n" +
	"\x19XChainAccountCreateCommit\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12 \n" +
	"\vdestination\x18\x02 \x01(\tR\vdestination\x12/\n" +
	"\x06amount\x18\x03 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\x12B\n" +
	"\x10signature_reward\x18\x04 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x0fsignatureReward\"\xf6\x03\n" +
	"\x19XChainAddClaimAttestation\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12<\n" +
	"\x1aattestation_signer_account\x18\x02 \x01(\tR\x18attestationSignerAccount\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\tR\tpublicKey\x12\x1c\n" +
	"\tsignature\x18\x04 \x01(\tR\tsignature\x12,\n" +
	"\x12other_chain_source\x18\x05 \x01(\tR\x10otherChainSource\x12/\n" +
	"\x06amount\x18\x06 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\x12<\n" +
	"\x1aattestation_reward_account\x18\a \x01(\tR\x18attestationRewardAccount\x123\n" +
	"\x16was_locking_chain_send\x18\b \x01(\bR\x13wasLockingChainSend\x12&\n" +
	"\x0fxchain_claim_id\x18\t \x01(\x04R\rxchainClaimId\x12 \n" +
	"\vdestination\x18\n" +
	" \x01(\tR\vdestination\"\xd9\x04\n" +
	"!XChainAddAccountCreateAttestation\x12B\n" +
	"\rxchain_bridge\x18\x01 \x01(\v2\x1d.sf.xrpl.type.v1.XChainBridgeR\fxchainBridge\x12<\n" +
	"\x1aattestation_signer_account\x18\x02 \x01(\tR\x18attestationSignerAccount\x12\x1d\n" +
	"\n" +
	"public_key\x18\x03 \x01(\tR\tpublicKey\x12\x1c\n" +
	"\tsignature\x18\x04 \x01(\tR\tsignature\x12,\n" +
	"\x12other_chain_source\x18\x05 \x01(\tR\x10otherChainSource\x12/\n" +
	"\x06amount\x18\x06 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\x12<\n" +
	"\x1aattestation_reward_account\x18\a \x01(\tR\x18attestationRewardAccount\x123\n" +
	"\x16was_locking_chain_send\x18\b \x01(\bR\x13wasLockingChainSend\x12=\n" +
	"\x1bxchain_account_create_count\x18\t \x01(\x04R\x18xchainAccountCreateCount\x12 \n" +
	"\vdestination\x18\n" +
	" \x01(\tR\vdestination\x12B\n" +
	"\x10signature_reward\x18\v \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x0fsignatureRewardBAZ?github.com/xrpl-commons/firehose-xrpl/pb/sf/xrpl/type/v1;pbxrplb\x06proto3"

var (
	file_sf_xrpl_type_v1_xchain_proto_rawDescOnce sync.Once
	file_sf_xrpl_type_v1_xchain_proto_rawDescData []byte
)

func file_sf_xrpl_type_v1_xchain_proto_rawDescGZIP() []byte {
	file_sf_xrpl_type_v1_xchain_proto_rawDescOnce.Do(func() {
		file_sf_xrpl_type_v1_xchain_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sf_xrpl_type_v1_xchain_proto_rawDesc), len(file_sf_xrpl_type_v1_xchain_proto_rawDesc)))
	})
	return file_sf_xrpl_type_v1_xchain_proto_rawDescData
}

var file_sf_xrpl_type_v1_xchain_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_sf_xrpl_type_v1_xchain_proto_goTypes = []any{
	(*XChainBridge)(nil),                      // 0: sf.xrpl.type.v1.XChainBridge
	(*XChainCreateBridge)(nil),                // 1: sf.xrpl.type.v1.XChainCreateBridge
	(*XChainModifyBridge)(nil),                // 2: sf.xrpl.type.v1.XChainModifyBridge
	(*XChainCreateClaimID)(nil),               // 3: sf.xrpl.type.v1.XChainCreateClaimID
	(*XChainCommit)(nil),                      // 4: sf.xrpl.type.v1.XChainCommit
	(*XChainClaim)(nil),                       // 5: sf.xrpl.type.v1.XChainClaim
	(*XChainAccountCreateCommit)(nil),         // 6: sf.xrpl.type.v1.XChainAccountCreateCommit
	(*XChainAddClaimAttestation)(nil),         // 7: sf.xrpl.type.v1.XChainAddClaimAttestation
	(*XChainAddAccountCreateAttestation)(nil), // 8: sf.xrpl.type.v1.XChainAddAccountCreateAttestation
	(*Asset)(nil),                             // 9: sf.xrpl.type.v1.Asset
	(*Amount)(nil),                            // 10: sf.xrpl.type.v1.Amount
}
var file_sf_xrpl_type_v1_xchain_proto_depIdxs = []int32{
	9,  // 0: sf.xrpl.type.v1.XChainBridge.locking_chain_issue:type_name -> sf.xrpl.type.v1.Asset
	9,  // 1: sf.xrpl.type.v1.XChainBridge.issuing_chain_issue:type_name -> sf.xrpl.type.v1.Asset
	0,  // 2: sf.xrpl.type.v1.XChainCreateBridge.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 3: sf.xrpl.type.v1.XChainCreateBridge.signature_reward:type_name -> sf.xrpl.type.v1.Amount
	10, // 4: sf.xrpl.type.v1.XChainCreateBridge.min_account_create_amount:type_name -> sf.xrpl.type.v1.Amount
	0,  // 5: sf.xrpl.type.v1.XChainModifyBridge.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 6: sf.xrpl.type.v1.XChainModifyBridge.signature_reward:type_name -> sf.xrpl.type.v1.Amount
	10, // 7: sf.xrpl.type.v1.XChainModifyBridge.min_account_create_amount:type_name -> sf.xrpl.type.v1.Amount
	0,  // 8: sf.xrpl.type.v1.XChainCreateClaimID.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 9: sf.xrpl.type.v1.XChainCreateClaimID.signature_reward:type_name -> sf.xrpl.type.v1.Amount
	0,  // 10: sf.xrpl.type.v1.XChainCommit.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 11: sf.xrpl.type.v1.XChainCommit.amount:type_name -> sf.xrpl.type.v1.Amount
	0,  // 12: sf.xrpl.type.v1.XChainClaim.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 13: sf.xrpl.type.v1.XChainClaim.amount:type_name -> sf.xrpl.type.v1.Amount
	0,  // 14: sf.xrpl.type.v1.XChainAccountCreateCommit.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 15: sf.xrpl.type.v1.XChainAccountCreateCommit.amount:type_name -> sf.xrpl.type.v1.Amount
	10, // 16: sf.xrpl.type.v1.XChainAccountCreateCommit.signature_reward:type_name -> sf.xrpl.type.v1.Amount
	0,  // 17: sf.xrpl.type.v1.XChainAddClaimAttestation.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 18: sf.xrpl.type.v1.XChainAddClaimAttestation.amount:type_name -> sf.xrpl.type.v1.Amount
	0,  // 19: sf.xrpl.type.v1.XChainAddAccountCreateAttestation.xchain_bridge:type_name -> sf.xrpl.type.v1.XChainBridge
	10, // 20: sf.xrpl.type.v1.XChainAddAccountCreateAttestation.amount:type_name -> sf.xrpl.type.v1.Amount
	10, // 21: sf.xrpl.type.v1.XChainAddAccountCreateAttestation.signature_reward:type_name -> sf.xrpl.type.v1.Amount
	22, // [22:22] is the sub-list for method output_type
	22, // [22:22] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_sf_xrpl_type_v1_xchain_proto_init() }
func file_sf_xrpl_type_v1_xchain_proto_init() {
	if File_sf_xrpl_type_v1_xchain_proto != nil {
		return
	}
	file_sf_xrpl_type_v1_amount_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sf_xrpl_type_v1_xchain_proto_rawDesc), len(file_sf_xrpl_type_v1_xchain_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sf_xrpl_type_v1_xchain_proto_goTypes,
		DependencyIndexes: file_sf_xrpl_type_v1_xchain_proto_depIdxs,
		MessageInfos:      file_sf_xrpl_type_v1_xchain_proto_msgTypes,
	}.Build()
	File_sf_xrpl_type_v1_xchain_proto = out.File
	file_sf_xrpl_type_v1_xchain_proto_goTypes = nil
	file_sf_xrpl_type_v1_xchain_proto_depIdxs = nil
}
