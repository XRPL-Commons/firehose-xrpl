// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: sf/xrpl/type/v1/nft.proto

package pbxrpl

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// NFTokenMint - Mints a new NFT
// Reference: https://xrpl.org/nftokenmint.html
type NFTokenMint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Taxon for this NFT (issuer-defined category)
	NftokenTaxon uint32 `protobuf:"varint,1,opt,name=nftoken_taxon,json=nftokenTaxon,proto3" json:"nftoken_taxon,omitempty"`
	// (Optional) Issuer if minting on behalf of another
	Issuer string `protobuf:"bytes,2,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// (Optional) Transfer fee (0-50000, representing 0-50%)
	TransferFee uint32 `protobuf:"varint,3,opt,name=transfer_fee,json=transferFee,proto3" json:"transfer_fee,omitempty"`
	// (Optional) URI pointing to token metadata (decoded from hex)
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// Transaction flags
	Flags         uint32 `protobuf:"varint,5,opt,name=flags,proto3" json:"flags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFTokenMint) Reset() {
	*x = NFTokenMint{}
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTokenMint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTokenMint) ProtoMessage() {}

func (x *NFTokenMint) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTokenMint.ProtoReflect.Descriptor instead.
func (*NFTokenMint) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_nft_proto_rawDescGZIP(), []int{0}
}

func (x *NFTokenMint) GetNftokenTaxon() uint32 {
	if x != nil {
		return x.NftokenTaxon
	}
	return 0
}

func (x *NFTokenMint) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

func (x *NFTokenMint) GetTransferFee() uint32 {
	if x != nil {
		return x.TransferFee
	}
	return 0
}

func (x *NFTokenMint) GetUri() string {
	if x != nil {
		return x.Uri
	}
	return ""
}

func (x *NFTokenMint) GetFlags() uint32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

// NFTokenBurn - Burns an existing NFT
// Reference: https://xrpl.org/nftokenburn.html
type NFTokenBurn struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the NFT to burn (64 hex chars)
	NftokenId string `protobuf:"bytes,1,opt,name=nftoken_id,json=nftokenId,proto3" json:"nftoken_id,omitempty"`
	// (Optional) Owner if burning on behalf of another
	Owner         string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFTokenBurn) Reset() {
	*x = NFTokenBurn{}
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTokenBurn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTokenBurn) ProtoMessage() {}

func (x *NFTokenBurn) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTokenBurn.ProtoReflect.Descriptor instead.
func (*NFTokenBurn) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_nft_proto_rawDescGZIP(), []int{1}
}

func (x *NFTokenBurn) GetNftokenId() string {
	if x != nil {
		return x.NftokenId
	}
	return ""
}

func (x *NFTokenBurn) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

// NFTokenCreateOffer - Creates an offer to buy or sell an NFT
// Reference: https://xrpl.org/nftokencreateoffer.html
type NFTokenCreateOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the NFT
	NftokenId string `protobuf:"bytes,1,opt,name=nftoken_id,json=nftokenId,proto3" json:"nftoken_id,omitempty"`
	// Amount offered (0 for free transfer)
	Amount *Amount `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	// (Optional) For buy offers, the NFT owner
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// (Optional) Specific account that can accept
	Destination string `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
	// (Optional) Expiration time
	Expiration uint32 `protobuf:"varint,5,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// Flags (1 = sell offer)
	Flags         uint32 `protobuf:"varint,6,opt,name=flags,proto3" json:"flags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFTokenCreateOffer) Reset() {
	*x = NFTokenCreateOffer{}
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTokenCreateOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTokenCreateOffer) ProtoMessage() {}

func (x *NFTokenCreateOffer) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTokenCreateOffer.ProtoReflect.Descriptor instead.
func (*NFTokenCreateOffer) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_nft_proto_rawDescGZIP(), []int{2}
}

func (x *NFTokenCreateOffer) GetNftokenId() string {
	if x != nil {
		return x.NftokenId
	}
	return ""
}

func (x *NFTokenCreateOffer) GetAmount() *Amount {
	if x != nil {
		return x.Amount
	}
	return nil
}

func (x *NFTokenCreateOffer) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *NFTokenCreateOffer) GetDestination() string {
	if x != nil {
		return x.Destination
	}
	return ""
}

func (x *NFTokenCreateOffer) GetExpiration() uint32 {
	if x != nil {
		return x.Expiration
	}
	return 0
}

func (x *NFTokenCreateOffer) GetFlags() uint32 {
	if x != nil {
		return x.Flags
	}
	return 0
}

// NFTokenCancelOffer - Cancels NFT offers
// Reference: https://xrpl.org/nftokencanceloffer.html
type NFTokenCancelOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of offer IDs to cancel
	NftokenOffers []string `protobuf:"bytes,1,rep,name=nftoken_offers,json=nftokenOffers,proto3" json:"nftoken_offers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFTokenCancelOffer) Reset() {
	*x = NFTokenCancelOffer{}
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTokenCancelOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTokenCancelOffer) ProtoMessage() {}

func (x *NFTokenCancelOffer) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTokenCancelOffer.ProtoReflect.Descriptor instead.
func (*NFTokenCancelOffer) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_nft_proto_rawDescGZIP(), []int{3}
}

func (x *NFTokenCancelOffer) GetNftokenOffers() []string {
	if x != nil {
		return x.NftokenOffers
	}
	return nil
}

// NFTokenAcceptOffer - Accepts an NFT offer
// Reference: https://xrpl.org/nftokenacceptoffer.html
type NFTokenAcceptOffer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// (Optional) Sell offer to accept
	NftokenSellOffer string `protobuf:"bytes,1,opt,name=nftoken_sell_offer,json=nftokenSellOffer,proto3" json:"nftoken_sell_offer,omitempty"`
	// (Optional) Buy offer to accept
	NftokenBuyOffer string `protobuf:"bytes,2,opt,name=nftoken_buy_offer,json=nftokenBuyOffer,proto3" json:"nftoken_buy_offer,omitempty"`
	// (Optional) Broker fee for brokered trades
	NftokenBrokerFee *Amount `protobuf:"bytes,3,opt,name=nftoken_broker_fee,json=nftokenBrokerFee,proto3" json:"nftoken_broker_fee,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *NFTokenAcceptOffer) Reset() {
	*x = NFTokenAcceptOffer{}
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTokenAcceptOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTokenAcceptOffer) ProtoMessage() {}

func (x *NFTokenAcceptOffer) ProtoReflect() protoreflect.Message {
	mi := &file_sf_xrpl_type_v1_nft_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTokenAcceptOffer.ProtoReflect.Descriptor instead.
func (*NFTokenAcceptOffer) Descriptor() ([]byte, []int) {
	return file_sf_xrpl_type_v1_nft_proto_rawDescGZIP(), []int{4}
}

func (x *NFTokenAcceptOffer) GetNftokenSellOffer() string {
	if x != nil {
		return x.NftokenSellOffer
	}
	return ""
}

func (x *NFTokenAcceptOffer) GetNftokenBuyOffer() string {
	if x != nil {
		return x.NftokenBuyOffer
	}
	return ""
}

func (x *NFTokenAcceptOffer) GetNftokenBrokerFee() *Amount {
	if x != nil {
		return x.NftokenBrokerFee
	}
	return nil
}

var File_sf_xrpl_type_v1_nft_proto protoreflect.FileDescriptor

const file_sf_xrpl_type_v1_nft_proto_rawDesc = "" +
	"\n" +
	"\x19sf/xrpl/type/v1/nft.proto\x12\x0fsf.xrpl.type.v1\x1a\x1csf/xrpl/type/v1/amount.proto\"\x95\x01\n" +
	"\vNFTokenMint\x12#\n" +
	"\rnftoken_taxon\x18\x01 \x01(\rR\fnftokenTaxon\x12\x16\n" +
	"\x06issuer\x18\x02 \x01(\tR\x06issuer\x12!\n" +
	"\ftransfer_fee\x18\x03 \x01(\rR\vtransferFee\x12\x10\n" +
	"\x03uri\x18\x04 \x01(\tR\x03uri\x12\x14\n" +
	"\x05flags\x18\x05 \x01(\rR\x05flags\"B\n" +
	"\vNFTokenBurn\x12\x1d\n" +
	"\n" +
	"nftoken_id\x18\x01 \x01(\tR\tnftokenId\x12\x14\n" +
	"\x05owner\x18\x02 \x01(\tR\x05owner\"\xd2\x01\n" +
	"\x12NFTokenCreateOffer\x12\x1d\n" +
	"\n" +
	"nftoken_id\x18\x01 \x01(\tR\tnftokenId\x12/\n" +
	"\x06amount\x18\x02 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x06amount\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12 \n" +
	"\vdestination\x18\x04 \x01(\tR\vdestination\x12\x1e\n" +
	"\n" +
	"expiration\x18\x05 \x01(\rR\n" +
	"expiration\x12\x14\n" +
	"\x05flags\x18\x06 \x01(\rR\x05flags\";\n" +
	"\x12NFTokenCancelOffer\x12%\n" +
	"\x0enftoken_offers\x18\x01 \x03(\tR\rnftokenOffers\"\xb5\x01\n" +
	"\x12NFTokenAcceptOffer\x12,\n" +
	"\x12nftoken_sell_offer\x18\x01 \x01(\tR\x10nftokenSellOffer\x12*\n" +
	"\x11nftoken_buy_offer\x18\x02 \x01(\tR\x0fnftokenBuyOffer\x12E\n" +
	"\x12nftoken_broker_fee\x18\x03 \x01(\v2\x17.sf.xrpl.type.v1.AmountR\x10nftokenBrokerFeeBAZ?github.com/xrpl-commons/firehose-xrpl/pb/sf/xrpl/type/v1;pbxrplb\x06proto3"

var (
	file_sf_xrpl_type_v1_nft_proto_rawDescOnce sync.Once
	file_sf_xrpl_type_v1_nft_proto_rawDescData []byte
)

func file_sf_xrpl_type_v1_nft_proto_rawDescGZIP() []byte {
	file_sf_xrpl_type_v1_nft_proto_rawDescOnce.Do(func() {
		file_sf_xrpl_type_v1_nft_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sf_xrpl_type_v1_nft_proto_rawDesc), len(file_sf_xrpl_type_v1_nft_proto_rawDesc)))
	})
	return file_sf_xrpl_type_v1_nft_proto_rawDescData
}

var file_sf_xrpl_type_v1_nft_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_sf_xrpl_type_v1_nft_proto_goTypes = []any{
	(*NFTokenMint)(nil),        // 0: sf.xrpl.type.v1.NFTokenMint
	(*NFTokenBurn)(nil),        // 1: sf.xrpl.type.v1.NFTokenBurn
	(*NFTokenCreateOffer)(nil), // 2: sf.xrpl.type.v1.NFTokenCreateOffer
	(*NFTokenCancelOffer)(nil), // 3: sf.xrpl.type.v1.NFTokenCancelOffer
	(*NFTokenAcceptOffer)(nil), // 4: sf.xrpl.type.v1.NFTokenAcceptOffer
	(*Amount)(nil),             // 5: sf.xrpl.type.v1.Amount
}
var file_sf_xrpl_type_v1_nft_proto_depIdxs = []int32{
	5, // 0: sf.xrpl.type.v1.NFTokenCreateOffer.amount:type_name -> sf.xrpl.type.v1.Amount
	5, // 1: sf.xrpl.type.v1.NFTokenAcceptOffer.nftoken_broker_fee:type_name -> sf.xrpl.type.v1.Amount
	2, // [2:2] is the sub-list for method output_type
	2, // [2:2] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_sf_xrpl_type_v1_nft_proto_init() }
func file_sf_xrpl_type_v1_nft_proto_init() {
	if File_sf_xrpl_type_v1_nft_proto != nil {
		return
	}
	file_sf_xrpl_type_v1_amount_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sf_xrpl_type_v1_nft_proto_rawDesc), len(file_sf_xrpl_type_v1_nft_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sf_xrpl_type_v1_nft_proto_goTypes,
		DependencyIndexes: file_sf_xrpl_type_v1_nft_proto_depIdxs,
		MessageInfos:      file_sf_xrpl_type_v1_nft_proto_msgTypes,
	}.Build()
	File_sf_xrpl_type_v1_nft_proto = out.File
	file_sf_xrpl_type_v1_nft_proto_goTypes = nil
	file_sf_xrpl_type_v1_nft_proto_depIdxs = nil
}
